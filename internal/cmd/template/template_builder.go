package template

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"

	cosmov1alpha1 "github.com/cosmo-workspace/cosmo/api/v1alpha1"
	"github.com/cosmo-workspace/cosmo/pkg/cli"
	"github.com/cosmo-workspace/cosmo/pkg/clog"
	"github.com/cosmo-workspace/cosmo/pkg/kubeutil"
	"github.com/cosmo-workspace/cosmo/pkg/template"
	"github.com/cosmo-workspace/cosmo/pkg/workspace"

	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/controller-runtime/pkg/client/apiutil"
	"sigs.k8s.io/kustomize/api/types"
	"sigs.k8s.io/yaml"
)

type TemplateObjectBuilder struct {
	tmpl              cosmov1alpha1.TemplateObject
	disableNamePrefix bool
	header            string
	resourceData      []string
}

func NewTemplateObjectBuilder(isClusterScope bool) *TemplateObjectBuilder {
	var b TemplateObjectBuilder

	if isClusterScope {
		b.tmpl = &cosmov1alpha1.ClusterTemplate{}
	} else {
		b.tmpl = &cosmov1alpha1.Template{}
	}

	scheme := runtime.NewScheme()
	if err := cosmov1alpha1.AddToScheme(scheme); err != nil {
		panic(err)
	}

	gvk, err := apiutil.GVKForObject(b.tmpl, scheme)
	if err != nil {
		panic(err)
	}
	b.tmpl.SetGroupVersionKind(gvk)
	return &b
}

func (b *TemplateObjectBuilder) Name(name string) *TemplateObjectBuilder {
	b.tmpl.SetName(name)
	return b
}

func (b *TemplateObjectBuilder) Description(desc string) *TemplateObjectBuilder {
	b.tmpl.GetSpec().Description = desc
	return b
}

func (b *TemplateObjectBuilder) RequiredVars(vars []string) *TemplateObjectBuilder {
	if len(vars) > 0 {
		vv := make([]cosmov1alpha1.RequiredVarSpec, 0, len(vars))
		for _, v := range vars {
			vcol := strings.Split(v, ":")
			varSpec := cosmov1alpha1.RequiredVarSpec{Var: vcol[0]}
			if len(vcol) > 1 {
				varSpec.Default = vcol[1]
			}
			vv = append(vv, varSpec)
		}
		b.tmpl.GetSpec().RequiredVars = vv
	}
	return b
}

func (b *TemplateObjectBuilder) SetUserRoles(roles []string) *TemplateObjectBuilder {
	if len(roles) > 0 {
		kubeutil.SetAnnotation(b.tmpl, cosmov1alpha1.TemplateAnnKeyUserRoles, strings.Join(roles, ","))
	}
	return b
}

func (b *TemplateObjectBuilder) SetRequiredAddons(addons []string) *TemplateObjectBuilder {
	if len(addons) > 0 {
		kubeutil.SetAnnotation(b.tmpl, cosmov1alpha1.TemplateAnnKeyRequiredAddons, strings.Join(addons, ","))
	}
	return b
}

func (b *TemplateObjectBuilder) Resources(rawYAML ...string) *TemplateObjectBuilder {
	b.resourceData = append(b.resourceData, rawYAML...)
	return b
}

func (b *TemplateObjectBuilder) DisableNamePrefix() *TemplateObjectBuilder {
	kubeutil.SetAnnotation(b.tmpl, cosmov1alpha1.TemplateAnnKeyDisableNamePrefix, strconv.FormatBool(true))
	b.disableNamePrefix = true
	return b
}

func (b *TemplateObjectBuilder) TypeUserAddon(setDefault bool) *TemplateObjectBuilder {
	template.SetTemplateType(b.tmpl, cosmov1alpha1.TemplateLabelEnumTypeUserAddon)
	if setDefault {
		kubeutil.SetAnnotation(b.tmpl, cosmov1alpha1.UserAddonTemplateAnnKeyDefaultUserAddon, strconv.FormatBool(true))
	}

	b.DisableNamePrefix()
	return b
}

func (b *TemplateObjectBuilder) TypeWorkspace(wscfg cosmov1alpha1.Config) *TemplateObjectBuilder {
	template.SetTemplateType(b.tmpl, cosmov1alpha1.TemplateLabelEnumTypeWorkspace)
	workspace.SetConfigOnTemplateAnnotations(b.tmpl, wscfg)
	return b
}

func (b *TemplateObjectBuilder) SetHeader(v cli.VersionInfo) *TemplateObjectBuilder {
	b.header = fmt.Sprintf("# Generated by cosmoctl - cosmo-workspace %s commit=%s build=%s\n", v.Version, v.Commit, v.Date)
	return b
}

func (b *TemplateObjectBuilder) Build(ctx context.Context) ([]byte, error) {
	kust := NewTempKustomizeBuilder()
	if b.disableNamePrefix {
		kust.DisableNamePrefix()
	}
	for _, r := range b.resourceData {
		kust.Resources(r)
	}

	rawYAML, err := kust.Build(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to kustomize build: %w", err)
	}
	b.tmpl.GetSpec().RawYaml = string(rawYAML)

	output, err := yaml.Marshal(b.tmpl)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal template object: %w", err)
	}

	if b.header != "" {
		output = append([]byte(b.header), output...)
	}
	return output, nil
}

type TempKustomizeBuilder struct {
	kust         types.Kustomization
	tmpDir       string
	resourceData []string
}

func NewTempKustomizeBuilder() *TempKustomizeBuilder {
	tmpDir, err := os.MkdirTemp(os.TempDir(), "cosmoctl-*")
	if err != nil {
		panic(err)
	}

	b := TempKustomizeBuilder{
		tmpDir:       tmpDir,
		resourceData: []string{},
	}
	b.kust = types.Kustomization{
		Labels: []types.Label{
			{
				Pairs: map[string]string{
					cosmov1alpha1.LabelKeyInstanceName: template.DefaultVarsInstance,
					cosmov1alpha1.LabelKeyTemplateName: template.DefaultVarsTemplate,
				},
				IncludeSelectors: true,
			},
		},
		Namespace:  template.DefaultVarsNamespace,
		Resources:  []string{},
		NamePrefix: template.DefaultVarsInstance + "-",
	}
	return &b
}

func (b *TempKustomizeBuilder) Resources(rawYAML ...string) *TempKustomizeBuilder {
	b.resourceData = append(b.resourceData, rawYAML...)
	return b
}

func (b *TempKustomizeBuilder) DisableNamePrefix() *TempKustomizeBuilder {
	b.kust.NamePrefix = ""
	return b
}

func (b *TempKustomizeBuilder) Build(ctx context.Context) ([]byte, error) {
	log := clog.FromContext(ctx).WithCaller()

	cmd, err := kustomizeBuildCmd()
	if err != nil {
		return nil, err
	}

	// save yaml in tmp and set resources
	for _, data := range b.resourceData {
		f, err := os.CreateTemp(b.tmpDir, "cosmoctl-*")
		if err != nil {
			return nil, fmt.Errorf("failed to create tmp file %s: %w", b.tmpDir, err)
		}
		if _, err := f.WriteString(data); err != nil {
			return nil, fmt.Errorf("failed to write file %s: %w", f.Name(), err)
		}
		b.kust.Resources = append(b.kust.Resources, f.Name())
	}

	kustYaml, err := yaml.Marshal(b.kust)
	if err != nil {
		return nil, err
	}
	log.Debug().Info(string(kustYaml), "obj", "kustomization.yaml")

	// create kustomization.yaml
	if err := os.WriteFile(filepath.Join(b.tmpDir, "kustomization.yaml"), kustYaml, 0644); err != nil {
		return nil, err
	}

	// run kustomize build
	kustomizeCmd := append(cmd, b.tmpDir)
	log.Debug().Info("kustomize cmd", "cmd", cmd)

	out, err := exec.CommandContext(ctx, kustomizeCmd[0], kustomizeCmd[1:]...).CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("failed to exec kustomize : %w : %s", err, out)
	}
	return out, nil
}

func kustomizeBuildCmd() ([]string, error) {
	kust, kustErr := exec.LookPath("kustomize")
	if kustErr != nil {
		kctl, kctlErr := exec.LookPath("kubectl")
		if kctlErr != nil {
			return nil, fmt.Errorf("kubectl nor kustomize found: kustmizr=%v, kubectl=%v", kustErr, kctlErr)
		}
		return []string{kctl, "kustomize"}, nil
	}
	return []string{kust, "build"}, nil
}

/* tslint:disable */
/* eslint-disable */
/**
 * Cosmo Dashboard API
 * Manipulate cosmo dashboard resource API
 *
 * The version of the OpenAPI document: v1alpha1
 * Contact: jlandowner8@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiV1alpha1UserAddons
 */
export interface ApiV1alpha1UserAddons {
    /**
     * 
     * @type {string}
     * @memberof ApiV1alpha1UserAddons
     */
    'template': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiV1alpha1UserAddons
     */
    'vars'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'authType'?: string;
    /**
     * 
     * @type {Array<ApiV1alpha1UserAddons>}
     * @memberof CreateUserRequest
     */
    'addons'?: Array<ApiV1alpha1UserAddons>;
}
/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateUserResponse
     */
    'message': string;
    /**
     * 
     * @type {User}
     * @memberof CreateUserResponse
     */
    'user': User | null;
}
/**
 * 
 * @export
 * @interface CreateWorkspaceRequest
 */
export interface CreateWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    'template': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateWorkspaceRequest
     */
    'vars'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateWorkspaceResponse
 */
export interface CreateWorkspaceResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceResponse
     */
    'message': string;
    /**
     * 
     * @type {Workspace}
     * @memberof CreateWorkspaceResponse
     */
    'workspace': Workspace | null;
}
/**
 * 
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    /**
     * 
     * @type {string}
     * @memberof DeleteUserResponse
     */
    'message': string;
    /**
     * 
     * @type {User}
     * @memberof DeleteUserResponse
     */
    'user': User | null;
}
/**
 * 
 * @export
 * @interface DeleteWorkspaceResponse
 */
export interface DeleteWorkspaceResponse {
    /**
     * 
     * @type {string}
     * @memberof DeleteWorkspaceResponse
     */
    'message': string;
    /**
     * 
     * @type {Workspace}
     * @memberof DeleteWorkspaceResponse
     */
    'workspace': Workspace | null;
}
/**
 * 
 * @export
 * @interface GetUserResponse
 */
export interface GetUserResponse {
    /**
     * 
     * @type {User}
     * @memberof GetUserResponse
     */
    'user': User | null;
}
/**
 * 
 * @export
 * @interface GetWorkspaceResponse
 */
export interface GetWorkspaceResponse {
    /**
     * 
     * @type {Workspace}
     * @memberof GetWorkspaceResponse
     */
    'workspace': Workspace | null;
}
/**
 * 
 * @export
 * @interface ListTemplatesResponse
 */
export interface ListTemplatesResponse {
    /**
     * 
     * @type {string}
     * @memberof ListTemplatesResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Template>}
     * @memberof ListTemplatesResponse
     */
    'items': Array<Template>;
}
/**
 * 
 * @export
 * @interface ListUsersResponse
 */
export interface ListUsersResponse {
    /**
     * 
     * @type {string}
     * @memberof ListUsersResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof ListUsersResponse
     */
    'items': Array<User>;
}
/**
 * 
 * @export
 * @interface ListWorkspaceResponse
 */
export interface ListWorkspaceResponse {
    /**
     * 
     * @type {string}
     * @memberof ListWorkspaceResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Workspace>}
     * @memberof ListWorkspaceResponse
     */
    'items': Array<Workspace>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'expireAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginResponse
     */
    'requirePasswordUpdate'?: boolean;
}
/**
 * 
 * @export
 * @interface NetworkRule
 */
export interface NetworkRule {
    /**
     * 
     * @type {string}
     * @memberof NetworkRule
     */
    'portName': string;
    /**
     * 
     * @type {number}
     * @memberof NetworkRule
     */
    'portNumber': number;
    /**
     * 
     * @type {string}
     * @memberof NetworkRule
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkRule
     */
    'httpPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkRule
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PatchWorkspaceRequest
 */
export interface PatchWorkspaceRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchWorkspaceRequest
     */
    'replicas'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchWorkspaceResponse
 */
export interface PatchWorkspaceResponse {
    /**
     * 
     * @type {string}
     * @memberof PatchWorkspaceResponse
     */
    'message': string;
    /**
     * 
     * @type {Workspace}
     * @memberof PatchWorkspaceResponse
     */
    'workspace': Workspace | null;
}
/**
 * 
 * @export
 * @interface RemoveNetworkRuleResponse
 */
export interface RemoveNetworkRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof RemoveNetworkRuleResponse
     */
    'message': string;
    /**
     * 
     * @type {NetworkRule}
     * @memberof RemoveNetworkRuleResponse
     */
    'networkRule': NetworkRule;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'description'?: string;
    /**
     * 
     * @type {Array<TemplateRequiredVars>}
     * @memberof Template
     */
    'requiredVars'?: Array<TemplateRequiredVars>;
    /**
     * 
     * @type {boolean}
     * @memberof Template
     */
    'isDefaultUserAddon'?: boolean | null;
}
/**
 * 
 * @export
 * @interface TemplateRequiredVars
 */
export interface TemplateRequiredVars {
    /**
     * 
     * @type {string}
     * @memberof TemplateRequiredVars
     */
    'varName': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateRequiredVars
     */
    'defaultValue'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserNameRequest
 */
export interface UpdateUserNameRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserNameRequest
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface UpdateUserNameResponse
 */
export interface UpdateUserNameResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserNameResponse
     */
    'message': string;
    /**
     * 
     * @type {User}
     * @memberof UpdateUserNameResponse
     */
    'user': User | null;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordRequest
 */
export interface UpdateUserPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordResponse
 */
export interface UpdateUserPasswordResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPasswordResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateUserRoleRequest
 */
export interface UpdateUserRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRoleRequest
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface UpdateUserRoleResponse
 */
export interface UpdateUserRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRoleResponse
     */
    'message': string;
    /**
     * 
     * @type {User}
     * @memberof UpdateUserRoleResponse
     */
    'user': User | null;
}
/**
 * 
 * @export
 * @interface UpsertNetworkRuleRequest
 */
export interface UpsertNetworkRuleRequest {
    /**
     * 
     * @type {number}
     * @memberof UpsertNetworkRuleRequest
     */
    'portNumber': number;
    /**
     * 
     * @type {string}
     * @memberof UpsertNetworkRuleRequest
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertNetworkRuleRequest
     */
    'httpPath'?: string;
}
/**
 * 
 * @export
 * @interface UpsertNetworkRuleResponse
 */
export interface UpsertNetworkRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof UpsertNetworkRuleResponse
     */
    'message': string;
    /**
     * 
     * @type {NetworkRule}
     * @memberof UpsertNetworkRuleResponse
     */
    'networkRule': NetworkRule;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: UserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'authType'?: UserAuthTypeEnum;
    /**
     * 
     * @type {Array<ApiV1alpha1UserAddons>}
     * @memberof User
     */
    'addons'?: Array<ApiV1alpha1UserAddons>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'defaultPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'status'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserRoleEnum {
    CosmoAdmin = 'cosmo-admin'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAuthTypeEnum {
    KosmoSecret = 'kosmo-secret'
}

/**
 * 
 * @export
 * @interface VerifyResponse
 */
export interface VerifyResponse {
    /**
     * 
     * @type {string}
     * @memberof VerifyResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyResponse
     */
    'expireAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof VerifyResponse
     */
    'requirePasswordUpdate'?: boolean;
}
/**
 * 
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'ownerID'?: string;
    /**
     * 
     * @type {WorkspaceSpec}
     * @memberof Workspace
     */
    'spec'?: WorkspaceSpec;
    /**
     * 
     * @type {WorkspaceStatus}
     * @memberof Workspace
     */
    'status'?: WorkspaceStatus;
}
/**
 * 
 * @export
 * @interface WorkspaceSpec
 */
export interface WorkspaceSpec {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSpec
     */
    'template': string;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceSpec
     */
    'replicas': number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WorkspaceSpec
     */
    'vars'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<NetworkRule>}
     * @memberof WorkspaceSpec
     */
    'additionalNetwork'?: Array<NetworkRule>;
}
/**
 * 
 * @export
 * @interface WorkspaceStatus
 */
export interface WorkspaceStatus {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceStatus
     */
    'phase': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceStatus
     */
    'mainUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceStatus
     */
    'urlBase'?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create session to login
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/v1alpha1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete session to logout
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1alpha1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify authorization
         * @summary Verify auth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1alpha1/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Create session to login
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete session to logout
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify authorization
         * @summary Verify auth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Create session to login
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete session to logout
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Verify authorization
         * @summary Verify auth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(options?: any): AxiosPromise<VerifyResponse> {
            return localVarFp.verify(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Create session to login
     * @summary Login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete session to logout
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify authorization
     * @summary Verify auth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verify(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).verify(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List templates typed useraddon
         * @summary List useraddon templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddonTemplates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1alpha1/template/useraddon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List templates typed workspace
         * @summary List workspace templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceTemplates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1alpha1/template/workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateApiAxiosParamCreator(configuration)
    return {
        /**
         * List templates typed useraddon
         * @summary List useraddon templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAddonTemplates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTemplatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAddonTemplates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List templates typed workspace
         * @summary List workspace templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceTemplates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTemplatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceTemplates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateApiFp(configuration)
    return {
        /**
         * List templates typed useraddon
         * @summary List useraddon templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddonTemplates(options?: any): AxiosPromise<ListTemplatesResponse> {
            return localVarFp.getUserAddonTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * List templates typed workspace
         * @summary List workspace templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceTemplates(options?: any): AxiosPromise<ListTemplatesResponse> {
            return localVarFp.getWorkspaceTemplates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     * List templates typed useraddon
     * @summary List useraddon templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getUserAddonTemplates(options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).getUserAddonTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List templates typed workspace
     * @summary List workspace templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getWorkspaceTemplates(options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).getWorkspaceTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete user by ID
         * @summary Delete user by ID.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('deleteUser', 'userid', userid)
            const localVarPath = `/api/v1alpha1/user/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single User model
         * @summary Get user by ID.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getUser', 'userid', userid)
            const localVarPath = `/api/v1alpha1/user/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of User model
         * @summary Get all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1alpha1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new User
         * @summary Create a new User
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser: async (createUserRequest: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('postUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/api/v1alpha1/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user display name
         * @summary Update user name
         * @param {string} userid user id
         * @param {UpdateUserNameRequest} updateUserNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserName: async (userid: string, updateUserNameRequest: UpdateUserNameRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('putUserName', 'userid', userid)
            // verify required parameter 'updateUserNameRequest' is not null or undefined
            assertParamExists('putUserName', 'updateUserNameRequest', updateUserNameRequest)
            const localVarPath = `/api/v1alpha1/user/{userid}/name`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserNameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a single User password
         * @summary Update user password
         * @param {string} userid user id
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserPassword: async (userid: string, updateUserPasswordRequest: UpdateUserPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('putUserPassword', 'userid', userid)
            // verify required parameter 'updateUserPasswordRequest' is not null or undefined
            assertParamExists('putUserPassword', 'updateUserPasswordRequest', updateUserPasswordRequest)
            const localVarPath = `/api/v1alpha1/user/{userid}/password`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a single User role
         * @summary Update user role
         * @param {string} userid user id
         * @param {UpdateUserRoleRequest} updateUserRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserRole: async (userid: string, updateUserRoleRequest: UpdateUserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('putUserRole', 'userid', userid)
            // verify required parameter 'updateUserRoleRequest' is not null or undefined
            assertParamExists('putUserRole', 'updateUserRoleRequest', updateUserRoleRequest)
            const localVarPath = `/api/v1alpha1/user/{userid}/role`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete user by ID
         * @summary Delete user by ID.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single User model
         * @summary Get user by ID.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of User model
         * @summary Get all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new User
         * @summary Create a new User
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUser(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUser(createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user display name
         * @summary Update user name
         * @param {string} userid user id
         * @param {UpdateUserNameRequest} updateUserNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserName(userid: string, updateUserNameRequest: UpdateUserNameRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserNameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserName(userid, updateUserNameRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a single User password
         * @summary Update user password
         * @param {string} userid user id
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserPassword(userid: string, updateUserPasswordRequest: UpdateUserPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserPasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserPassword(userid, updateUserPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a single User role
         * @summary Update user role
         * @param {string} userid user id
         * @param {UpdateUserRoleRequest} updateUserRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserRole(userid: string, updateUserRoleRequest: UpdateUserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserRole(userid, updateUserRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Delete user by ID
         * @summary Delete user by ID.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userid: string, options?: any): AxiosPromise<DeleteUserResponse> {
            return localVarFp.deleteUser(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single User model
         * @summary Get user by ID.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userid: string, options?: any): AxiosPromise<GetUserResponse> {
            return localVarFp.getUser(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of User model
         * @summary Get all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): AxiosPromise<ListUsersResponse> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new User
         * @summary Create a new User
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<CreateUserResponse> {
            return localVarFp.postUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user display name
         * @summary Update user name
         * @param {string} userid user id
         * @param {UpdateUserNameRequest} updateUserNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserName(userid: string, updateUserNameRequest: UpdateUserNameRequest, options?: any): AxiosPromise<UpdateUserNameResponse> {
            return localVarFp.putUserName(userid, updateUserNameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a single User password
         * @summary Update user password
         * @param {string} userid user id
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserPassword(userid: string, updateUserPasswordRequest: UpdateUserPasswordRequest, options?: any): AxiosPromise<UpdateUserPasswordResponse> {
            return localVarFp.putUserPassword(userid, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a single User role
         * @summary Update user role
         * @param {string} userid user id
         * @param {UpdateUserRoleRequest} updateUserRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserRole(userid: string, updateUserRoleRequest: UpdateUserRoleRequest, options?: any): AxiosPromise<UpdateUserRoleResponse> {
            return localVarFp.putUserRole(userid, updateUserRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Delete user by ID
     * @summary Delete user by ID.
     * @param {string} userid user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userid: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single User model
     * @summary Get user by ID.
     * @param {string} userid user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userid: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of User model
     * @summary Get all users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new User
     * @summary Create a new User
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUser(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).postUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user display name
     * @summary Update user name
     * @param {string} userid user id
     * @param {UpdateUserNameRequest} updateUserNameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public putUserName(userid: string, updateUserNameRequest: UpdateUserNameRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).putUserName(userid, updateUserNameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a single User password
     * @summary Update user password
     * @param {string} userid user id
     * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public putUserPassword(userid: string, updateUserPasswordRequest: UpdateUserPasswordRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).putUserPassword(userid, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a single User role
     * @summary Update user role
     * @param {string} userid user id
     * @param {UpdateUserRoleRequest} updateUserRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public putUserRole(userid: string, updateUserRoleRequest: UpdateUserRoleRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).putUserRole(userid, updateUserRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove workspace network rule
         * @summary Remove workspace network rule
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {string} networkRuleName network rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetworkRule: async (userid: string, wsName: string, networkRuleName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('deleteNetworkRule', 'userid', userid)
            // verify required parameter 'wsName' is not null or undefined
            assertParamExists('deleteNetworkRule', 'wsName', wsName)
            // verify required parameter 'networkRuleName' is not null or undefined
            assertParamExists('deleteNetworkRule', 'networkRuleName', networkRuleName)
            const localVarPath = `/api/v1alpha1/user/{userid}/workspace/{wsName}/network/{networkRuleName}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)))
                .replace(`{${"wsName"}}`, encodeURIComponent(String(wsName)))
                .replace(`{${"networkRuleName"}}`, encodeURIComponent(String(networkRuleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete workspace
         * @summary Delete workspace.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (userid: string, wsName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('deleteWorkspace', 'userid', userid)
            // verify required parameter 'wsName' is not null or undefined
            assertParamExists('deleteWorkspace', 'wsName', wsName)
            const localVarPath = `/api/v1alpha1/user/{userid}/workspace/{wsName}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)))
                .replace(`{${"wsName"}}`, encodeURIComponent(String(wsName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Workspace model
         * @summary Get workspace by name.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace: async (userid: string, wsName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getWorkspace', 'userid', userid)
            // verify required parameter 'wsName' is not null or undefined
            assertParamExists('getWorkspace', 'wsName', wsName)
            const localVarPath = `/api/v1alpha1/user/{userid}/workspace/{wsName}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)))
                .replace(`{${"wsName"}}`, encodeURIComponent(String(wsName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Workspace model
         * @summary Get all workspace of user.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaces: async (userid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getWorkspaces', 'userid', userid)
            const localVarPath = `/api/v1alpha1/user/{userid}/workspace`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update workspace
         * @summary Update workspace.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {PatchWorkspaceRequest} patchWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkspace: async (userid: string, wsName: string, patchWorkspaceRequest: PatchWorkspaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('patchWorkspace', 'userid', userid)
            // verify required parameter 'wsName' is not null or undefined
            assertParamExists('patchWorkspace', 'wsName', wsName)
            // verify required parameter 'patchWorkspaceRequest' is not null or undefined
            assertParamExists('patchWorkspace', 'patchWorkspaceRequest', patchWorkspaceRequest)
            const localVarPath = `/api/v1alpha1/user/{userid}/workspace/{wsName}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)))
                .replace(`{${"wsName"}}`, encodeURIComponent(String(wsName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWorkspaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Workspace
         * @summary Create a new Workspace
         * @param {string} userid user id
         * @param {CreateWorkspaceRequest} createWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspace: async (userid: string, createWorkspaceRequest: CreateWorkspaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('postWorkspace', 'userid', userid)
            // verify required parameter 'createWorkspaceRequest' is not null or undefined
            assertParamExists('postWorkspace', 'createWorkspaceRequest', createWorkspaceRequest)
            const localVarPath = `/api/v1alpha1/user/{userid}/workspace`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert workspace network rule
         * @summary Upsert workspace network rule
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {string} networkRuleName network rule name
         * @param {UpsertNetworkRuleRequest} upsertNetworkRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putNetworkRule: async (userid: string, wsName: string, networkRuleName: string, upsertNetworkRuleRequest: UpsertNetworkRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('putNetworkRule', 'userid', userid)
            // verify required parameter 'wsName' is not null or undefined
            assertParamExists('putNetworkRule', 'wsName', wsName)
            // verify required parameter 'networkRuleName' is not null or undefined
            assertParamExists('putNetworkRule', 'networkRuleName', networkRuleName)
            // verify required parameter 'upsertNetworkRuleRequest' is not null or undefined
            assertParamExists('putNetworkRule', 'upsertNetworkRuleRequest', upsertNetworkRuleRequest)
            const localVarPath = `/api/v1alpha1/user/{userid}/workspace/{wsName}/network/{networkRuleName}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)))
                .replace(`{${"wsName"}}`, encodeURIComponent(String(wsName)))
                .replace(`{${"networkRuleName"}}`, encodeURIComponent(String(networkRuleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertNetworkRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove workspace network rule
         * @summary Remove workspace network rule
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {string} networkRuleName network rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetworkRule(userid: string, wsName: string, networkRuleName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveNetworkRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetworkRule(userid, wsName, networkRuleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete workspace
         * @summary Delete workspace.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(userid: string, wsName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteWorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(userid, wsName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single Workspace model
         * @summary Get workspace by name.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspace(userid: string, wsName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(userid, wsName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of Workspace model
         * @summary Get all workspace of user.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaces(userid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaces(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update workspace
         * @summary Update workspace.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {PatchWorkspaceRequest} patchWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWorkspace(userid: string, wsName: string, patchWorkspaceRequest: PatchWorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PatchWorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchWorkspace(userid, wsName, patchWorkspaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Workspace
         * @summary Create a new Workspace
         * @param {string} userid user id
         * @param {CreateWorkspaceRequest} createWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWorkspace(userid: string, createWorkspaceRequest: CreateWorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWorkspace(userid, createWorkspaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert workspace network rule
         * @summary Upsert workspace network rule
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {string} networkRuleName network rule name
         * @param {UpsertNetworkRuleRequest} upsertNetworkRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putNetworkRule(userid: string, wsName: string, networkRuleName: string, upsertNetworkRuleRequest: UpsertNetworkRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertNetworkRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putNetworkRule(userid, wsName, networkRuleName, upsertNetworkRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * Remove workspace network rule
         * @summary Remove workspace network rule
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {string} networkRuleName network rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetworkRule(userid: string, wsName: string, networkRuleName: string, options?: any): AxiosPromise<RemoveNetworkRuleResponse> {
            return localVarFp.deleteNetworkRule(userid, wsName, networkRuleName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete workspace
         * @summary Delete workspace.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(userid: string, wsName: string, options?: any): AxiosPromise<DeleteWorkspaceResponse> {
            return localVarFp.deleteWorkspace(userid, wsName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Workspace model
         * @summary Get workspace by name.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(userid: string, wsName: string, options?: any): AxiosPromise<GetWorkspaceResponse> {
            return localVarFp.getWorkspace(userid, wsName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Workspace model
         * @summary Get all workspace of user.
         * @param {string} userid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaces(userid: string, options?: any): AxiosPromise<ListWorkspaceResponse> {
            return localVarFp.getWorkspaces(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update workspace
         * @summary Update workspace.
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {PatchWorkspaceRequest} patchWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWorkspace(userid: string, wsName: string, patchWorkspaceRequest: PatchWorkspaceRequest, options?: any): AxiosPromise<PatchWorkspaceResponse> {
            return localVarFp.patchWorkspace(userid, wsName, patchWorkspaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Workspace
         * @summary Create a new Workspace
         * @param {string} userid user id
         * @param {CreateWorkspaceRequest} createWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWorkspace(userid: string, createWorkspaceRequest: CreateWorkspaceRequest, options?: any): AxiosPromise<CreateWorkspaceResponse> {
            return localVarFp.postWorkspace(userid, createWorkspaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert workspace network rule
         * @summary Upsert workspace network rule
         * @param {string} userid user id
         * @param {string} wsName workspace name
         * @param {string} networkRuleName network rule name
         * @param {UpsertNetworkRuleRequest} upsertNetworkRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putNetworkRule(userid: string, wsName: string, networkRuleName: string, upsertNetworkRuleRequest: UpsertNetworkRuleRequest, options?: any): AxiosPromise<UpsertNetworkRuleResponse> {
            return localVarFp.putNetworkRule(userid, wsName, networkRuleName, upsertNetworkRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * Remove workspace network rule
     * @summary Remove workspace network rule
     * @param {string} userid user id
     * @param {string} wsName workspace name
     * @param {string} networkRuleName network rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteNetworkRule(userid: string, wsName: string, networkRuleName: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteNetworkRule(userid, wsName, networkRuleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete workspace
     * @summary Delete workspace.
     * @param {string} userid user id
     * @param {string} wsName workspace name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspace(userid: string, wsName: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspace(userid, wsName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Workspace model
     * @summary Get workspace by name.
     * @param {string} userid user id
     * @param {string} wsName workspace name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspace(userid: string, wsName: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspace(userid, wsName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Workspace model
     * @summary Get all workspace of user.
     * @param {string} userid user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaces(userid: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaces(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update workspace
     * @summary Update workspace.
     * @param {string} userid user id
     * @param {string} wsName workspace name
     * @param {PatchWorkspaceRequest} patchWorkspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public patchWorkspace(userid: string, wsName: string, patchWorkspaceRequest: PatchWorkspaceRequest, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).patchWorkspace(userid, wsName, patchWorkspaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Workspace
     * @summary Create a new Workspace
     * @param {string} userid user id
     * @param {CreateWorkspaceRequest} createWorkspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public postWorkspace(userid: string, createWorkspaceRequest: CreateWorkspaceRequest, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).postWorkspace(userid, createWorkspaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert workspace network rule
     * @summary Upsert workspace network rule
     * @param {string} userid user id
     * @param {string} wsName workspace name
     * @param {string} networkRuleName network rule name
     * @param {UpsertNetworkRuleRequest} upsertNetworkRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public putNetworkRule(userid: string, wsName: string, networkRuleName: string, upsertNetworkRuleRequest: UpsertNetworkRuleRequest, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).putNetworkRule(userid, wsName, networkRuleName, upsertNetworkRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


